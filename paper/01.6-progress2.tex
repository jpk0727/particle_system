\section{Current Progress 2}

During this time period, we worked a lot with the imported octree implementation.  We spent a lot of time reading through and understanding the different methods and the approaches to implementing collision detection.  

Another large focus of ours was particle collision.  To try to better understand what was going on, we first implemented particle collision by simply checking every particle against every other particle.  It was clear tha our runtime was very slow because the animation was very laggy. We then looked to use our octree for performance benifits. Eventually we realized that the ISpatialObject method VCheckCollisions handled all of the particle collision work.  We adjusted this method in or particle class to work correctly and implemented basics physics equations so that the particles interact appropriatly when a collision occurs for a bouncing ball. (eventually we will try altering our equations to make the behaviour more accuratly model water)  However, there is a bug in which particle collisions occur only about half of the time we run our program.  We are working to locate and eliminate this bug. However we are definitly seeing major performance benifits with our octree implementation which is very exciting because this gives us an indication that it is working. The octree subdevides the space recursivly into 8 octants to a depth of 5. Instead of checking each particle with each other, the octree allows us to only check for a particle collision with particles within each octant. 

In addition, we improved our wall collision detection by adding a method that checks if a point is on a plane, rather than hardcoding in which boundaries the particles should adhere to. We also fixed the behavior of our wall collision so that energy is perseved. In other words, when a ball drops from a certain height, the ball could bounce back to the same height if friction was not present. However, we add a coefficient of friction for both ball collisions and wall collisions so that after a while the particles reach a steady state.  In this way, our particles should be able to interact with any kind of flat surface.  Eventually, we would like to be able to rotate our cube (or tank) and have the particles respond accordingly (i.e. pour out of the box).  While we already had rotational features implemented for the camera, we successfully added rotations to the cube's actual verticies so that the particle's collisions with the walls of this cube should be affected.  The cube rotation is working but the particles are not yet responding correctly.  

Moving forward our three main goals are as follows:

\begin{itemize}
  \item{ Fix the particle collision bug and ensure particle collisions work at all times}
  \item{ Make the particles react accordingly to the rotating cube}
  \item{Implement better velocity/position algorithms for particle movement (right now they act more like bouncing balls).  We need to think about surface water vs. water below the surface and the cohesive factor of water. 
}
\end{itemize}

